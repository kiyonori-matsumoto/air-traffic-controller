# 航空管制シミュレーションのための物理エンジンアーキテクチャと航空機性能モデルの包括的設計

## 1. 序論

### 1.1 研究の背景と目的

航空管制（Air Traffic Control, ATC）シミュレーションの開発において、物理エンジンの設計はシステムの信頼性とユーザー体験（UX）を決定づける最も重要な要素の一つである。一般的なフライトシミュレーターが単一の航空機の操縦応答性や空力特性の精密な再現（例えば、翼型ごとの揚力分布やプロペラ後流の影響など）に主眼を置くのに対し、ATCシミュレーションは数百機規模の航空機が同時に飛行する空域全体の交通流を、物理的な整合性を保ちながらリアルタイムで処理することを目的とする。

本報告書は、航空管制ゲームおよび訓練シミュレーターの開発を目的とし、最低限のリアリティ（Plausibility）と計算効率（Scalability）を両立させる物理シミュレーションエンジンの設計論を体系化するものである。具体的には、3自由度（3DOF）点質点モデルの数学的導出、航空機性能データの構造化、自動操縦装置（オートパイロット）の制御ロジック、および衝突検知アルゴリズムの実装詳細について、既存の学術研究および産業界の標準技術（Eurocontrol BADA, OpenAP等）に基づき、包括的な技術指針を提供する。

### 1.2 シミュレーションの忠実度とスケーラビリティのトレードオフ

ATCシミュレーションにおける最大の技術的課題は、個々の航空機の挙動の「もっともらしさ」と、システム全体のスケーラビリティのバランスにある 。高忠実度な6自由度（6DOF）モデルは、機体の回転運動（ピッチ、ロール、ヨー）を慣性モーメントや各舵面の空力係数に基づいて計算するが、これには膨大な計算リソースと、機体ごとの詳細な空力データが必要となる 。一方で、航空管制官が業務上認識するのは、航空機の微細な姿勢変化ではなく、その結果として現れる軌跡（トラジェクトリ）、対地速度（Ground Speed）、上昇・降下率（Vertical Speed）である。

したがって、本報告書では、回転運動の方程式を簡略化しつつ、エネルギー保存則や推力・抗力のバランスを厳密に考慮した「性能ベース3自由度点質点モデル（Performance-Based 3DOF Point-Mass Model）」を推奨解として提示する 。このアプローチにより、計算コストを最小限に抑えつつ、旋回半径の物理的制約や高度変化に伴う速度変化といった、航空管制において本質的な挙動を再現することが可能となる。

---

## 2. 座標系と空間表現の数学的基礎

航空機の位置をシミュレーション空間内で正確に表現するためには、地球の曲率を考慮した地理座標系と、物理計算に適したデカルト座標系の間の適切な変換アルゴリズムが不可欠である。

### 2.1 地理座標系とデカルト座標系の選定

航空機ナビゲーションの基本データ（ウェイポイント、空港位置、航空路）は、世界測地系（WGS84）に基づく緯度（$\phi$）、経度（$\lambda$）、高度（$h$）で定義される。一方、物理エンジンの内部計算（速度ベクトルの加算、距離判定、衝突検知）は、メートル単位のユークリッド空間（$x, y, z$）で行うのが一般的である 。

### 2.1.1 地球中心地球固定座標系（ECEF）

最も厳密な方法は、WGS84楕円体上の座標を、地球重心を原点とする3次元直交座標系（ECEF: Earth-Centered, Earth-Fixed）に変換することである。

$$
\begin{aligned}
X &= (N(\phi) + h) \cos\phi \cos\lambda \\
Y &= (N(\phi) + h) \cos\phi \sin\lambda \\
Z &= (N(\phi)(1-e^2) + h) \sin\phi
\end{aligned}
$$

ここで、$N(\phi)$は卯酉線曲率半径、$e$は離心率である。この方法は全世界をシームレスに扱える利点があるが、重力ベクトルが位置によって変化するため、「上（Up）」の定義が場所ごとに異なり、航空機の姿勢計算（ピッチ、ロール）が複雑化する欠点がある。

### 2.1.2 局所接平面座標系（LTP / ENU）

ATCシミュレーションにおいては、特定の空港やレーダーサイトを原点（Reference Point: $\phi_{ref}, \lambda_{ref}$）とした局所接平面座標系（Local Tangent Plane）の採用が推奨される。これは、原点における地球表面に接する平面を定義し、東方向を$x$、北方向を$y$、天頂方向を$z$とするENU（East-North-Up）座標系である 。

小規模から中規模の空域（半径数百km以内）であれば、以下の正距円筒図法近似（Equirectangular Projection approximation）を用いることで、計算負荷を大幅に低減できる。

$$
\begin{aligned}
x &= R_e \cdot (\lambda - \lambda_{ref}) \cdot \cos(\phi_{ref}) \\
y &= R_e \cdot (\phi - \phi_{ref}) \\
z &= h
\end{aligned}
$$

ここで、$R_e$は地球の平均半径（約6,371km）である。この近似式は、緯度が高くなるほど経度間の距離が縮まることを $\cos(\phi_{ref})$ 項で補正しているが、極点付近や広大な空域（数千km規模）では歪みが無視できなくなるため注意が必要である 。

**表 1: 座標系モデルの比較**

| **座標系モデル**           | **適用範囲** | **計算コスト**                     | **物理的な正確性**   | **推奨ユースケース**                 |
| -------------------------- | ------------ | ---------------------------------- | -------------------- | ------------------------------------ |
| **ECEF (地球中心)**        | 全世界       | 高（重力ベクトルの常時更新が必要） | 極めて高い           | フライトシミュレータ、ICBM軌道計算   |
| **LTP / ENU (局所接平面)** | 半径 ~500km  | 低（重力ベクトル固定可能）         | 高（範囲内）         | **空港管制、ターミナルレーダー管制** |
| **Flat Earth (完全平面)**  | 半径 ~50km   | 極低                               | 低（長距離で誤差大） | 簡易アーケードゲーム                 |

### 2.2 レーダー表示のための投影法

ATCのレーダースクリーンは3次元空間を2次元平面に投影したものである。実際の航空管制システムでは、**平射図法（Stereographic Projection）**や**心射図法（Gnomonic Projection）**が一般的に用いられる 。

- **心射図法（Gnomonic Projection）**: 地球の中心から投影する方法。大圏コース（最短経路）が直線として表示されるため、ナビゲーション計画に適しているが、中心から離れるほど地形や距離の歪みが大きくなる。
- **平射図法（Stereographic Projection）**: 角度（形状）を保存する正角図法であり、局所的な形状の歪みが少ないため、旋回半径や相対的な位置関係を直感的に把握しやすい。

ゲームエンジン（UnityやUnreal Engine）で実装する場合、シーンの中心を原点としたENU座標系を採用し、描画カメラをOrthographic（正投影）に設定することで、擬似的にこれらの投影効果を得ることができる。

### 2.3 距離と方位の計算アルゴリズム

物理シミュレーション内での距離計算には、計算速度を優先してデカルト座標でのユークリッド距離（$d^2 = \Delta x^2 + \Delta y^2$）を用いることが一般的である。しかし、正確なナビゲーションや広域での距離計測には、球面三角法に基づく**Haversineの公式**を実装する必要がある 。

2点間の大圏距離 $d$ の計算式：

$$a = \sin^2\left(\frac{\Delta\phi}{2}\right) + \cos\phi_1 \cos\phi_2 \sin^2\left(\frac{\Delta\lambda}{2}\right) \\ c = 2 \cdot \text{atan2}(\sqrt{a}, \sqrt{1-a}) \\ d = R_e \cdot c$$

初期方位角（Bearing）$\theta$ の計算式：

$$\theta = \text{atan2}(\sin\Delta\lambda \cdot \cos\phi_2, \cos\phi_1 \sin\phi_2 - \sin\phi_1 \cos\phi_2 \cos\Delta\lambda)$$

---

## 3. 航空機運動モデル（Dynamics & Kinematics）

ATCゲームにおける「リアリティ」の核心は、航空機が物理法則に従って動いているように見えることである。これは、単に位置を移動させるだけでなく、加速、旋回、上昇・降下といった運動が、機体の質量や空力特性、推力の限界に基づいて制約されていることを意味する。

### 3.1 3DOF 点質点モデルの定式化

前述の通り、ATCシミュレーションには3DOF点質点モデルが最適である。このモデルでは、航空機を質量のある点として扱い、並進運動（位置の変化）のみを運動方程式で解く。姿勢角（ロール、ピッチ、ヨー）は、力の釣り合い（Coordinated Flight）を仮定して代数的に導出する 。

### 3.1.1 状態変数（State Variables）

シミュレーションにおける航空機の状態ベクトル $\mathbf{x}$ は以下のように定義される。

- $V$: 真対気速度（True Airspeed, TAS）
- $\gamma$: 経路角（Flight Path Angle, 水平線に対する上下角度）
- $\psi$: 偏流角（Heading/Track Angle, 真北に対する方位）
- $x, y, h$: 慣性座標系における位置（東、北、高度）
- $m$: 機体質量

### 3.1.2 作用する力（Forces）

航空機に作用する4つの主要な力：

1. **推力 ($T, Thrust$)**: エンジンが発生させる力。パイロット（またはオートパイロット）のスロットル操作によって制御される。
2. **抗力 ($D, Drag$)**: 空力抵抗。速度の二乗に比例する。

   $$D = \frac{1}{2}\rho V^2 S C_D$$

3. **揚力 ($L, Lift$)**: 重力および旋回時の遠心力を支える力。

   $$L = \frac{1}{2}\rho V^2 S C_L$$

4. **重力 ($W, Weight$)**: 地球の中心に向かう力。

   $$W = mg$$

### 3.1.3 運動方程式（Equations of Motion）

風がないと仮定した場合の運動方程式は以下の連立常微分方程式系で記述される 。

1. **速度の変化（加速・減速）**:

   $$\dot{V} = \frac{T - D}{m} - g \sin\gamma$$

   この式は、推力と抗力の差が加速を生み、重力の経路方向成分（$g \sin\gamma$）が減速（上昇時）または加速（降下時）に寄与することを示している。

2. **経路角の変化（垂直方向の軌道制御）**:

   $$\dot{\gamma} = \frac{L \cos\phi - mg \cos\gamma}{mV}$$

   ここで$\phi$はロール角（バンク角）である。旋回中は揚力の一部が旋回のための求心力として消費されるため（$L \cos\phi$）、垂直方向の揚力成分が減少し、推力を増やさなければ高度を維持できない（機首が下がる）という物理現象を数式化したものである。

3. **方位角の変化（旋回ダイナミクス）**:

   $$\dot{\psi} = \frac{L \sin\phi}{mV \cos\gamma}$$

   これが旋回の基本式である。揚力の水平成分（$L \sin\phi$）が求心力となり、旋回を生み出す。水平飛行（$\gamma \approx 0$）かつ釣り合い旋回（$L \approx mg / \cos\phi$）と仮定すると、パイロットによく知られた以下の旋回率の式が導かれる 。

   $$\dot{\psi} = \frac{g \tan\phi}{V}$$

   この式は、速度$V$が大きいほど旋回率（Rate of Turn）が小さくなり旋回半径が大きくなること、バンク角$\phi$が大きいほど急旋回になることを物理的に正しく表現している。

4. **位置の更新（キネマティクス）**:

   $$
   \begin{aligned}
   \dot{x} &= V \cos\gamma \sin\psi + W_x \\
   \dot{y} &= V \cos\gamma \cos\psi + W_y \\
   \dot{h} &= V \sin\gamma
   \end{aligned}
   $$

   ここで$W_x, W_y$は風速成分である。

### 3.2 旋回半径とロードファクターの制約

シミュレーションにおいて特に重要なのが、旋回性能の物理的限界である。プレイヤーが急旋回を指示したとしても、航空機は構造強度や失速限界によって制限を受ける。

### 3.2.1 荷重倍数（Load Factor）

旋回中、機体には遠心力がかかり、見かけの重力が増加する。これを荷重倍数 $n$ と呼ぶ 。

$$n = \frac{L}{W} = \frac{1}{\cos\phi}$$

例えば、バンク角60度の旋回では $n = 1 / \cos(60^\circ) = 2.0$ G となる。民間航空機では、通常運航時のバンク角は最大30度（$n \approx 1.15$ G）程度に制限される。シミュレーションでは、バンク角 $\phi$ を最大値（例：$\pm 30^\circ$）でクランプすることで、非現実的な急旋回を防止する。

### 3.2.2 失速速度の変化

荷重倍数が増加すると、失速速度（Stall Speed）も上昇する。

$$V_{stall, turn} = V_{stall, level} \cdot \sqrt{n}$$

この関係式を実装することで、低速飛行時に急旋回を行うと失速警報が作動する、あるいは旋回が維持できずに高度が落ちるといったリアルな挙動を再現できる。

### 3.3 風の影響とウィンドトライアングル

ATCシミュレーションにおいて、風の影響はナビゲーションの難易度や到着予定時刻（ETA）の計算に直結する重要な要素である 。

- **対気速度（TAS: True Airspeed）**: 航空機が空気に対して進む速度。空気力（揚力・抗力）の計算に使用。
- **対地速度（GS: Ground Speed）**: 地面に対する速度。位置の更新に使用。
- **偏流角（Drift Angle）**: 機首方位（Heading）と進行方向（Track/Course）の差。

ベクトル関係式：

$$\vec{V}_{GS} = \vec{V}_{TAS} + \vec{W}_{wind}$$

シミュレーション実装においては、以下のように計算を行う：

1. オートパイロットが「目標コース（Track）」を維持するために必要な「機首方位（Heading）」を計算する（Wind Correction Angleの算出）。
2. あるいは、現在のHeadingとTASに風ベクトルを加算して、実際の移動方向（Track）とGSを算出する。

---

## 4. 航空機性能モデルとデータベース設計

物理エンジン（EOM）は「航空機がどのように動くか」という法則を定義するが、「その航空機がどれくらいの性能で動けるか」を定義するのが性能モデル（Performance Model）である。B747のような大型機とC172のような小型機では、推力、重量、抗力特性が全く異なる。

### 4.1 データソース：BADAとOpenAP

航空機性能データの業界標準はEurocontrolの**BADA (Base of Aircraft Data)** であるが、厳格なライセンス契約が必要であり、一般のゲーム開発には利用できない場合が多い 。
これに対する強力な代替手段として、TU Delftの研究チーム等が開発したオープンソースの**OpenAP (Open Aircraft Performance)** が存在する 。OpenAPは、推力、抗力、燃料消費率などのパラメータを、公開情報や文献値から推計してデータベース化しており、Pythonライブラリとして提供されているが、その係数データはJSONやYAML形式で抽出可能であるため、C#やC++等の他言語エンジンにも容易に移植できる。

### 4.2 全エネルギーモデル（Total Energy Model: TEM）

ATCシミュレーションにおける性能計算、特に上昇・降下性能の算出には、全エネルギーモデル（TEM）が標準的に用いられる 。これは、「エンジンが発生する余剰出力（Power）は、位置エネルギー（高度）の増加と、運動エネルギー（速度）の増加に分配される」という物理保存則に基づくモデルである。

$$(T - D) V = mg \dot{h} + mV \dot{V}$$

この式を変形することで、特定条件下での最大上昇率（Rate of Climb, ROC）を導出できる：

$$\dot{h} = \frac{(T - D) V}{mg} \cdot \frac{1}{1 + \frac{V}{g} \frac{dV}{dh}}$$

右辺の分母にある項 $1 + \frac{V}{g} \frac{dV}{dh}$ は**エネルギー分配係数（Energy Share Factor, ESF）**と呼ばれる 。

- **定速上昇（Constant CAS Climb）**: 高度が上がると空気密度が下がるため、同じ指示対気速度（CAS）でも真対気速度（TAS）は増加する（$\frac{dV}{dh} > 0$）。そのため、エンジンのエネルギーの一部は加速（運動エネルギー増）に消費され、その分だけ上昇率（位置エネルギー増）が減少する。
- **定マッハ上昇（Constant Mach Climb）**: 音速は高度（温度）と共に下がるため、一定マッハ数で上昇するとTASは減少する（$\frac{dV}{dh} < 0$）。この場合、運動エネルギーが位置エネルギーに変換されるため、上昇率はブーストされる。

### 4.3 推力と抗力の簡易モデル化

ゲーム開発においては、OpenAP等のデータを基に、以下のようなパラメトリックモデルを実装する。

### 4.3.1 抗力モデル（Drag Model）

抗力係数 $C_D$ は、揚力係数 $C_L$ の関数として放物線近似（Drag Polar）で表される。

$$C_D = C_{D0} + C_{D2} C_L^2$$

ここで、$C_{D0}$ は寄生抗力係数（形状抵抗）、$C_{D2}$ は誘導抗力係数である。これらの値は、フラップやギア（着陸装置）の展開状態（Configuration）によって変化する 。

### 4.3.2 推力モデル（Thrust Model）

ジェットエンジンの最大推力 $T_{max}$ は、高度と速度に依存する。一般に、高度が上がると空気密度が下がるため推力は低下する。

$$T_{max}(h, V) = T_{ref} \cdot \left(\frac{\rho}{\rho_0}\right)^a \cdot (1 - c_1 M - c_2 h)$$

シミュレーション内では、パイロットのスロットル操作 $\delta_T$ ($0.0 \sim 1.0$) を用いて、実推力 $T = \delta_T \cdot T_{max}$ を計算する 。

### 4.4 性能データの構造化と代表値

航空機の種別ごとに性能データをJSON形式で定義することで、拡張性の高いシステムを構築できる 。

表 2: 代表的な航空機カテゴリと性能パラメータ

| **カテゴリ**      | **代表機種**    | **巡航速度 (Cruise TAS)** | **初期上昇率 (ROC)** | **実用上昇限度 (Service Ceiling)** | **失速速度 (Landing Vso)** | **航跡乱流区分 (Wake Turb)** |
| ----------------- | --------------- | ------------------------- | -------------------- | ---------------------------------- | -------------------------- | ---------------------------- |
| **Heavy (大型)**  | B747-400 / A380 | M0.85 (490 kts)           | 2,000 - 3,000 fpm    | 43,000 - 45,000 ft                 | ~145 kts                   | Heavy                        |
| **Medium (中型)** | B737-800 / A320 | M0.78 (450 kts)           | 2,500 - 3,500 fpm    | 39,000 - 41,000 ft                 | ~135 kts                   | Medium                       |
| **Light (小型)**  | Cessna 172      | 110 - 120 kts             | 700 - 1,000 fpm      | 13,000 - 15,000 ft                 | ~45 kts                    | Light                        |

JSON

#

`// JSONデータ例: B737-800
{
  "id": "B738",
  "category": "Medium",
  "wake_turbulence": "M",
  "performance": {
    "cruise": { "mach": 0.78, "tas_knots": 450 },
    "climb": { "roc_fpm": 3000, "speed_cas": 250 },
    "descent": { "rod_fpm": -1500, "speed_cas": 250 },
    "limits": {
      "max_altitude_ft": 41000,
      "max_bank_deg": 30,
      "stall_speed_clean_knots": 140,
      "stall_speed_landing_knots": 110
    }
  },
  "aerodynamics": {
    "wing_area_m2": 124.6,
    "cd0_clean": 0.018,
    "cd2_clean": 0.045
  }
}`

---

## 5. 誘導制御システム（Guidance & Control）

物理エンジンが「機体の動き」を計算する一方、オートパイロット（AP）は「プレイヤーの指示を物理的な制御入力に変換する」役割を担う。ATCゲームでは、プレイヤーが「高度FL330へ上昇」「方位270へ旋回」といったマクロな指令を出し、APがそれを実行する形式が一般的である。

### 5.1 PID制御の実装

目標値へのスムーズかつ安定した収束を実現するために、産業界で標準的な**PID制御（比例・積分・微分制御）**を用いる 。

### 5.1.1 制御ループの階層構造（Cascaded Control Loops）

航空機の制御は、外側のループ（Outer Loop）が内側のループ（Inner Loop）への指令値を生成する階層構造で設計する。

1. **ナビゲーション層（Outer Loop）**:
   - 入力: 目標高度、目標ウェイポイント
   - 出力: 目標ピッチ角（$\theta_{cmd}$）、目標バンク角（$\phi_{cmd}$）
   - 制御周期: 低速（例: 1Hz - 5Hz）
2. **姿勢制御層（Inner Loop）**:
   - 入力: 目標ピッチ角、目標バンク角
   - 出力: エレベーター、エルロン（3DOFモデルでは直接、角速度 $\dot{\gamma}, \dot{\psi}$ を制御）
   - 制御周期: 高速（例: 20Hz - 60Hz）

### 5.1.2 高度制御ロジック（Altitude Acquire / Hold）

高度制御には、現在の高度と目標高度の偏差（Error）に基づき、目標昇降率（Vertical Speed）を算出し、それを実現するためのピッチ角を制御する。

- **ステップ1: 目標昇降率の決定**
  $$\dot{h}_{cmd} = \text{Clamp}(K_p (h_{target} - h_{current}), \text{ROD}_{max}, \text{ROC}_{max})$$
  目標高度に近づくにつれて昇降率を徐々に減らすことで、オーバーシュートを防ぐ。
- **ステップ2: ピッチ角の制御**
  昇降率を実現するために必要なピッチ角 $\theta$ は、経路角 $\gamma$ と迎角 $\alpha$ の和であるが、簡易的には $\dot{h} \approx V \sin\theta$ とみなして制御する。
  $$\theta_{cmd} = \text{PID}(\dot{h}_{cmd} - \dot{h}_{current})$$
- **推力の連携**:
  上昇モード（FLCH SPD等）では、通常スロットルを最大（N1 Limit）に固定し、ピッチ角で速度を維持しながら上昇する「Speed on Pitch」ロジックが採用される 。一方、高度維持（Altitude Hold）モードでは、ピッチで高度を一定に保ち、スロットルで速度を制御する「Speed on Thrust」ロジックに切り替わる。このモード遷移の実装が、リアリティ向上の鍵となる。

### 5.1.3 方位制御ロジック（LNAV / Heading Select）

- **最短旋回方向の判定**: 現在の方位 $\psi$ と目標方位 $\psi_{cmd}$ の差分 $\Delta\psi$ を計算し、$-\pi \le \Delta\psi \le \pi$ の範囲に正規化する。
- **バンク角指令**:
  $$\phi_{cmd} = \text{PID}(\Delta\psi)$$
  出力されたバンク角は、最大バンク角（例：25度または30度）で制限（Clamp）する。また、ロールレート（Roll Rate, バンク角の変化速度）にも制限（例：最大15度/秒）を設けることで、機体が瞬時に傾く非現実的な挙動を防ぐ。

### 5.2 ナビゲーションアルゴリズム

ウェイポイント間のルート追従には、単純に「目標点への方位」を向くだけでは、横風がある場合にコースから流されてしまう。これを補正するための誘導則が必要である。

- **カニ流し（Crabbing）**: 横風成分を打ち消すために、機首を風上に意図的に向ける（Wind Correction Angle）。
- **旋回先行（Turn Anticipation）**: ウェイポイントの真上で旋回を開始すると、旋回半径の分だけコースを逸脱する（オーバーシュート）。これを防ぐため、"Fly-by" 方式では、旋回半径 $R$ と変針角度 $\alpha$ から旋回開始距離 $d_{start}$ を計算し、手前で旋回を開始する。
  $$d_{start} = R \cdot \tan\left(\frac{\alpha}{2}\right)$$

---

## 6. 衝突検知と回避（Collision Detection & Separation）

ATCゲームの主要なメカニクスである「セパレーション維持」とその破綻（コンフリクト）を検知するためのアルゴリズムについて詳述する。

### 6.1 最近接点（CPA: Closest Point of Approach）のベクトル演算

2機の航空機が現在の速度ベクトルを維持した場合、将来的に最も接近する瞬間（CPA）と、その時の距離を予測することは、事前警告（Conflict Prediction）に不可欠である 。

航空機A（位置 $\mathbf{P}_A$, 速度 $\mathbf{V}_A$）と航空機B（位置 $\mathbf{P}_B$, 速度 $\mathbf{V}_B$）とする。

相対位置ベクトル $\mathbf{P} = \mathbf{P}_B - \mathbf{P}_A$

相対速度ベクトル $\mathbf{V} = \mathbf{V}_B - \mathbf{V}_A$

距離の二乗 $D^2(t) = |\mathbf{P} + \mathbf{V}t|^2$ が最小になる時間 $t_{CPA}$ は、これを $t$ で微分して0とおくことで求められる。

$$t_{CPA} = - \frac{\mathbf{P} \cdot \mathbf{V}}{|\mathbf{V}|^2}$$

- もし $t_{CPA} < 0$ ならば、2機はすでに遠ざかりつつある（発散）。
- もし $t_{CPA} > 0$ ならば、将来接近する可能性がある。この時の最小距離 $d_{CPA}$ は：
  $$d_{CPA} = |\mathbf{P} + \mathbf{V}t_{CPA}|$$

この $d_{CPA}$ が規定のセパレーション基準（例：水平5海里）未満であり、かつ高度差が規定値（例：1000フィート）未満である場合、将来的な衝突（Loss of Separation）として警告を発する。

### 6.2 空間分割による計算最適化

航空機数 $N$ が増加すると、総当たり（All-to-All）の衝突判定コストは $O(N^2)$ で増大する。数百機規模のシミュレーションでは、**空間分割（Spatial Partitioning）**アルゴリズムによる最適化が必須となる 。

### 6.2.1 空間ハッシング（Spatial Hashing）またはグリッド法

空域を固定サイズ（例：10海里四方）のグリッドセルに分割し、各航空機がどのセルに属するかを管理する。

1. **ブロードフェーズ（Broad Phase）**: 各航空機が属するセルおよび隣接するセルのリストを取得する。計算量は $O(N)$。
2. **ナローフェーズ（Narrow Phase）**: 同じセルまたは隣接セルに存在する航空機ペアに対してのみ、前述のCPA計算や高度差判定を行う。

### 6.2.2 高度フィルタリング

航空管制では高度差が決定的なセパレーション要因であるため、2次元グリッド分割に加え、高度帯（Altitude Band）によるフィルタリングを併用するのが効果的である。例えば、高度差が2000フィート以上あるペアは、水平位置に関わらず即座に除外できる。

---

## 7. ソフトウェアアーキテクチャと実装設計

これまでに論じた物理モデルとロジックを統合する、堅牢なソフトウェアアーキテクチャを提案する。

### 7.1 クラス設計と責務の分離

オブジェクト指向設計により、物理計算、航空機データ、制御ロジックを明確に分離する。

- **`AircraftDynamics` クラス**:
  - **責務**: 運動方程式（EOM）の数値積分、位置・速度ベクトルの更新。
  - **メソッド**: `Integrate(dt)`, `ApplyForces()`
  - **データ**: Position (Lat/Lon/Alt), Velocity (Vector3), Mass.
- **`AircraftPerformance` クラス**:
  - **責務**: 機体固有の性能データの提供。JSONデータベースからのロード。
  - **メソッド**: `GetDragPolar()`, `GetMaxThrust(alt, speed)`, `GetFuelFlow()`.
- **`Autopilot` クラス**:
  - **責務**: ターゲット状態（高度、方位、速度）の保持とPID制御。
  - **メソッド**: `UpdateControlLoop(current_state, dt)`.
  - **内部**: `PIDController` インスタンス（Pitch, Bank, Throttle用）.
- **`Atmosphere` クラス**:
  - **責務**: 環境情報の提供。標準大気モデル（ISA）の実装。
  - **メソッド**: `GetDensity(alt)`, `GetWindVector(pos, alt)`.

### 7.2 シミュレーションループ（Fixed Update Loop）

物理シミュレーションの安定性を保つため、描画フレームレート（FPS）とは独立した固定時間ステップ（Fixed Time Step）での更新ループを実装する 。

Python

#

`# 擬似コード：物理エンジンの更新サイクル
TIME_STEP = 0.05 # 20Hz update

def physics_tick():
for aircraft in all_aircraft: # 1. 環境情報の取得
rho = Atmosphere.GetDensity(aircraft.alt)
wind = Atmosphere.GetWind(aircraft.pos)

        # 2. オートパイロット制御 (Guidance)
        # ターゲットとの偏差から、目標ピッチ角・バンク角・スロットルを決定
        controls = aircraft.Autopilot.Calculate(aircraft.State, dt=TIME_STEP)

        # 3. 力の計算 (Dynamics)
        # 性能データと環境情報から、推力・抗力・揚力を算出
        thrust = aircraft.Performance.GetThrust(controls.throttle, aircraft.alt, aircraft.speed)
        drag = aircraft.Performance.GetDrag(aircraft.speed, aircraft.config)

        # 4. 運動方程式の積分 (Integration)
        # 加速度、旋回率、上昇率を計算し、状態を更新
        aircraft.Dynamics.UpdateState(thrust, drag, controls.bank, controls.pitch, wind, dt=TIME_STEP)

        # 5. 衝突検知 (Collision Detection)
        # 空間ハッシュを用いて近隣機体とのCPAをチェック
        CollisionManager.CheckConflicts(aircraft)`

このアーキテクチャにより、物理挙動のリアリティ、システムの拡張性、および数百機を処理可能なパフォーマンスを同時に実現することが可能となる。

---

## 8. 結論

本報告書では、航空管制ゲーム開発に向けた物理シミュレーションエンジンの設計手法について包括的に論じた。結論として、以下の3点が開発の要諦となる。

1. **3DOF点質点モデルの採用**: 6DOFモデルの計算コストと複雑さを回避しつつ、ATC業務に必要な軌跡のリアリティを担保する最適解である。
2. **データ駆動型の性能モデル**: OpenAP等のオープンデータを活用し、全エネルギーモデル（TEM）に基づいた推力・抗力計算を実装することで、大型機から小型機までの多様な性能差を表現する。
3. **階層的PID制御と空間分割**: スムーズなオートパイロット挙動を実現する制御理論と、大量のトラフィックを効率的に処理するアルゴリズムの融合が、ゲームとしてのプレイアビリティを支える。

これらの技術的指針に基づき実装を行うことで、プレイヤーに納得感のあるリアルな航空交通環境を提供しつつ、エンターテインメントとして成立するATCシミュレーションの開発が可能となるだろう。
